














[{"categories":["Infraestrutura"],"contents":"Hoje, vou trazer uma solu√ß√£o interessante para o neg√≥cio que permite o gerenciamento centralizado de desktops virtuais, facilidade de acesso, flexibilidade, maior seguran√ßa e mobilidade do usu√°rio\nBasicamente, o VDI (Infraestrutura de desktop virtual) faz uso de m√°quinas virtuais para fornecer e gerenciar Desktops Virtuais\nEm resumo, √© uma tecnologia que hospeda os sistemas numa infra central e os disponibiliza acesso desktop para os usu√°rios\nCom 3 elementos base em sua estrutura:\n Virtualiza√ß√£o + NAS Broker Terminais de acesso  O funcionamento √© +/- esse:\n o hypervisor segmenta desktops em m√°quinas virtuais. Cada desktop virtual inclui uma imagem do sistema operacional Os usu√°rios se conectam √†s inst√¢ncias de desktop por meio de um intermedi√°rio de conex√£o (broker), que √© um gateway com base em software que atua como intermedi√°rio entre o usu√°rio e o servidor. Ele encontra um desktop virtual dentro do pool de recursos para cada cliente se conectar ap√≥s seu acesso bem-sucedido os usu√°rios podem acessar esses desktops virtuais em qualquer dispositivo ou local atrav√©s de softwares de acesso remoto. Todo o processamento √© feito no servidor central. Fortalece o conceito de BYOD - \u0026ldquo;traga voc√™ mesmo seu dispositivo\u0026rdquo;  As vantagens desse modelo s√£o enormes. Podendo ser on-premise (HCI e cloud privada) ou em servi√ßos DaaS (Desktop as a Service) em cloud p√∫blica\nPor fim, como solu√ß√£o Full-Stack open source, em infra local, trago a FlexVDI\nE como op√ß√µes para cada pilar do VDI, deixo:\n Virtualiza√ß√£o: Proxmox NAS: TrueNAS Broker: Ravada ThinClient: Remmina  E a√≠? Curtiu?\nSimbora!!\n#tecnologia #opensource\nRefer√™ncias  Proxmox: https://www.proxmox.com/en/ TrueNAS https://www.truenas.com/ Ravada https://ravada.upc.edu/ Remmina https://remmina.org/ FlexVID https://flexvdi.com/en/index  ","date":"03 Dec, 2021","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/2021_12_virtualizacao_hu3d03a01dcc18bc5be0e67db3d8d209a6_185679_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/2021_12_virtualizacao_hu3d03a01dcc18bc5be0e67db3d8d209a6_185679_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/2021_12_virtualizacao_hu3d03a01dcc18bc5be0e67db3d8d209a6_185679_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/2021_12_virtualizacao_hu3d03a01dcc18bc5be0e67db3d8d209a6_185679_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/2021_12_virtualizacao_hu3d03a01dcc18bc5be0e67db3d8d209a6_185679_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1470\" height=\"981\"\u003e\n\u003c/picture\u003e\n \n \n \n\n\n","permalink":"https://ricardoferreira.site/blog/virtualizacao-de-desktop-vdi-infraestrutura-open-source/","tags":["vdi","desktop"],"title":"Virtualiza√ß√£o de Desktop usando Infraestrutura Open Source"},{"categories":["Docker"],"contents":"Tendo em vista a Metodologia \u0026ldquo;The Twelve-Factor App\u0026rdquo;, criada por Adam Wiggins, co-fundador da PaaS Heroku, que preconiza todo software cloud entregue como servi√ßo deve seguir algumas premissas de desenvolvimento que impulsonam o uso da arquitetura de Microservi√ßos, eu apresento uma solu√ß√£o web simples que demonstra na pr√°tica o emprego de todos os 12 fatores da Metodologia!\nPor que Microservi√ßo? ü§® Microservi√ßo √© um conceito que garante que uma aplica√ß√£o possa ser dividida em m√∫ltiplos servi√ßos menores (microservi√ßos) que se comunicam entre si, tradicionalmente, via APIs Rest (m√©todos GET/POST/PUT/DELETE do protocolo HTTP + JSON).\nAs principais vantagens s√£o:\n Cada microservi√ßo √© independente garantindo baixo acoplamento e possui responsabilidade √∫nica garantindo alta coes√£o melhorando a manuten√ß√£o do c√≥digo e reuso do software Desse modo os pontos de falhas tendem a serem isolodados mais facilmente gatarantido a resil√™ncia do software. Por outro lado, aumentam-se os pontos de falhas que exigem maior esfor√ßo no monitoramento para a mitiga√ß√£o efeciente das falhas Modelagem com base em conceitos de neg√≥cio (Domain-Driven Design) evitando uma modelagem falha e baseada puramente em aspectos t√©cnicos Autonomia e indeped√™ncia exigem automa√ß√£o no deploy que facilitam a implementa√ß√£o de t√©cnicas de CI/CD vistas no DevOps Cada microservi√ßo pode ter sua pr√≥pria linguaguem de desenvolvimento, databases e ferramentas Tudo passa a ser orientado por eventos e mensagens entre as partes Totalmente aplic√°vel a escalonar horizontalmente seu software. Aqui encaixa-se o uso de orquestradores de containers, como Swarm e Kubernetes  Tudo isso confronta com as pr√°ticas tradicionais de desenvolvimento que estabelecem um √∫nico ponto (famoso mon√≥lito) de cria√ß√£o. Dificultando a manuten√ß√£o, concentrando as falhas e diminuindo a resili√™ncia j√° que a aplica√ß√£o precisar√° parar ou reiniciar, por completo caso o m√≥dulo de upload precise de atualiza√ßa√µ ou tenha dado problema, por exemplo.\nQual √© dessa Metodologia a√≠? ü§î Ela sintetiza, em 12 fatores, boas pr√°ticas de desenvolvimento de aplica√ß√£o web. Ela √©, altamente, recomendada para qualquer Desenvolvedor que esteja construindo aplica√ß√µes que rodam como servi√ßo e Engenheiros de Opera√ß√µes que implantam ou administram tais aplica√ß√µes! Recomenda√ß√µes do pr√≥prio autor.\nEstes fatores s√£o realmente um √≥timo \u0026lsquo;guideline\u0026rsquo; para direcionar a melhor maneira para construir uma aplica√ß√£o baseada em microservi√ßo, pois oferecem maneiras para garantir os principais pilares dos microservi√ßos, tais como: independ√™ncia, resili√™ncia, autonomia, descentraliza√ß√£o e escalabilidade.\nSendo assim, os 12 fatores s√£o:\n1. Base de C√≥digo ‚ÄúCodebase‚Äù  Uma base de c√≥digo com rastreamento utilizando controle de revis√£o\n 2. Depend√™ncias ‚ÄúDependencies‚Äù  Declare e isole as depend√™ncias\n 3. Configura√ß√µes ‚ÄúConfig‚Äù  Armazene as configura√ß√µes no ambiente\n 4. Servi√ßos de Apoio ‚ÄúBacking Services‚Äù  Trate os servi√ßos de apoio, como recursos ligados\n 5. Construa, lance, execute ‚ÄúBuild, Run, Release‚Äù  Separe estritamente os builds e execute em est√°gios\n 6. Processos ‚ÄúStateless Processes‚Äù  Execute a aplica√ß√£o como um ou mais processos que n√£o armazenam estado\n 7. V√≠nculo de porta ‚ÄúPort Binding‚Äù:  Exporte servi√ßos por liga√ß√£o de porta\n 8. Concorr√™ncia \u0026ldquo;Concurrency\u0026rdquo;  Dimensione por um modelo de processo\n 9. Descartabilidade \u0026ldquo;Disposability\u0026rdquo;  Maximizar a robustez com inicializa√ß√£o e desligamento r√°pido\n 10. Dev/prod semelhantes \u0026ldquo;Dev-Prod Parity\u0026rdquo;  Mantenha o desenvolvimento, teste, produ√ß√£o o mais semelhante poss√≠vel\n 11. Logs  Trate logs como fluxo de eventos\n 12. Processos de Admin \u0026ldquo;Admin Processes\u0026rdquo;  Executar tarefas de administra√ß√£o/gerenciamento como processos pontuais\n Veja na pr√°tica! ü§ò Vis√£o geral do projeto:\nTecnicamente, √© uma aplica√ß√£o web PHP em arquitetura de microservi√ßo com containers Docker que se conecta via API Restful Flask com mapeamento objeto-relacional SQLAlchemy, escrito em Python, com persist√™ncia em banco de dados PostgreSQL.\nA fim de garantir que voc√™ tenha uma maior absor√ß√£o do que est√° sendo apresentado aqui, acesse o c√≥digo completo desse projeto no meu GitHub e acompanhe em detalhes como cada trecho e recurso foi adotado tendo como base a Metodologia discutida anteriormente.\nLeia o Readme para proceder com a execu√ß√£o e veja na pr√°tica seu funcionamento!\nEsse artigo foi criado por conta da aula \u0026ldquo;Microservi√ßo na pr√°tica - aplica√ß√£o web PHP simples conectada via API Restful\u0026rdquo; apresentado no meu curso de Introdu√ß√£o a Docker! Curtiu? Eu quero o curso\n O escopo aqui n√£o √© provisionamento e orquestra√ß√£o da aplica√ß√£o, apenas apresentar pr√°ticas de desenvolvimento em microservi√ßos usando containers Docker. Por isso, n√£o abordo as diferentes etapas de desenvolvimento!\n \n1. Base de C√≥digo \u0026ldquo;Codebase\u0026rdquo; Esteja sempre centrado no versionamento do c√≥digo, em diferentes etapas do desenvolvimento integrado e continuado (development, staging, production, etc) e ciente de que existe apenas uma base de c√≥digo por aplica√ß√£o, mas existir√£o v√°rios deploys da mesma.\nAcesse toda a base de c√≥digo desse projeto no meu GitHub aqui!\n2. Depend√™ncias \u0026ldquo;Dependencies\u0026rdquo; No projeto, eu uso o arquivo requirements.txt que usa o gerenciador de pacotes pip3 e o virtualenv do Python. Isso mant√©m declarada e isolada explicitamente, respectivamente, todas as depend√™ncias, e suas vers√µes, do projeto.\nOs services API mant√™m essa caracter√≠stica.\n1flask==1.0.2 2flask-sqlalchemy==2.3.0 3psycopg2==2.8.4 3. Configura√ß√µes \u0026ldquo;Config\u0026rdquo; Mantenha todas as configura√ß√µes do ambiente declaradas \u0026ldquo;fora do c√≥digo\u0026rdquo;. Isso auxilia a administra√ß√£o entre os diversos tipos de etapas do desenvolvimento. Evite armazenar as configura√ß√µes no c√≥digo como constantes, por exemplo: vari√°veis de conex√£o com banco de dados. Pois, esse 4¬∫ fator exige uma estrita separa√ß√£o entre configura√ß√£o e c√≥digo!\nTendo isso em vista, √© poss√≠vel observar que eu uso os arquivos de configura√ß√£o de conex√£o com o banco PostgreSQL expl√≠citos nos arquivos database.conf em todos os services que persistem dados. Inclusive, elas s√£o passadas como vari√°veis de ambiente (ENVs) no docker-compose.yml:\nPOSTGRES_USER=test POSTGRES_PASSWORD=password POSTGRES_HOST=localhost POSTGRES_PORT=5432 POSTGRES_DB=books 1version: \u0026#39;3.5\u0026#39; 2services: 3 database-books: 4 image: postgres:13-alpine 5 env_file: db-books/database.conf 6 volumes: 7 - db_volume-books:/var/lib/postgresql/data 8#rest of code 4. Servi√ßos de Apoio \u0026ldquo;Backing Services\u0026rdquo; A fim de garantir boa portabilidade e f√°cil manuten√ß√£o, trate servi√ßos de apoio, como persist√™ncia de dados, mensageria e envio de e-mails, como um \u0026ldquo;recurso anexado\u0026rdquo; que facilmente pode ser alterado e n√£o causar grandes impactos ou mudan√ßas de c√≥digo. Tudo isso garante baixo acoplamento ao deploy!\nSendo assim, no meu caso, atr√°ves do docker-compose, eu consigo anexar e desanexar facilmente os recursos de containers de persist√™ncia de dados. No caso o service do PostgreSQL. Inclusive, posso alterar de vers√£o ou indicar outro volume de dados que nenhuma mudan√ßa de c√≥digo √© exigida:\n1version: \u0026#39;3.5\u0026#39; 2services: 3 database-books: 4 image: postgres:13-alpine 5 env_file: db-books/database.conf 6 volumes: 7 - db_volume-books:/var/lib/postgresql/data 8#rest of code 5. Construa, lance, execute \u0026ldquo;Build, Run, Release\u0026rdquo; Esse fator refor√ßa as etapas do desenvolvimento moderno conhecidos como Build, Release e Run stages. Inclusive, automa√ß√£o de deploy.\nMesmo n√£o sendo escopo do meu projeto, tenho uma base de c√≥digo (fator 1) que √© pr√©-requisito para esse crit√©rio! Veja mais sobre aqui\n6. Processos \u0026ldquo;Stateless Processes\u0026rdquo; Esse fator est√° no \u0026ldquo;core\u0026rdquo; da arquitetura de microservi√ßos. Ela preconiza que voc√™ n√£o deve salvar estado em seus servi√ßos, pois aplica√ß√µes devem executar como um √∫nico processo sem armazenar estado. Isso garante a alta coes√£o e mant√©m a responsabilidade √∫nica!\n\u0026ldquo;Sem armazenar estado\u0026rdquo; est√° relacionado com a persist√™ncia dos dados dos microservi√ßos. No caso de containers Dockers isso √© primordial, pois containers s√£o vol√°teis e n√£o armazenam estado (pegou a ideia?). Logo, precisa usar um servi√ßo de apoio stateful (que armazena o seu estado), tipicamente uma base de dados.\nNo meu caso, simplesmente o fato de ter um container PostgreSQL n√£o garante esse fator. Para tal, foi preciso criar um objeto Docker volume para persistir todos os dados de banco:\n9 volumes: 10 - db_volume-books:/var/lib/postgresql/data 11#rest of code 7. V√≠nculo de Portas \u0026ldquo;Port Binding\u0026rdquo; De acordo com esse fator, a aplica√ß√£o web deve exportar requisi√ß√£o HTTP como um servi√ßo atrav√©s da vincula√ß√£o a uma porta e escutar as requisi√ß√µes que chegam na mesma. Dessa maneira, ao vincular portas, um servi√ßo pode se tornar apoio para um outro servi√ßos, provendo a URL do microservi√ßo como um identificador de recurso na configura√ß√£o do microservi√ßo consumidor.\nNo meu caso, no microservi√ßo web, no arquivo index.php, eu tive que informar a URL e porta do microservi√ßo da API Restful Flask para ele \u0026ldquo;consumir\u0026rdquo; as requisi√ß√µes de sa√≠da exibindo os dados na web:\n1\u0026lt;?php 2$_ENV[\u0026#39;URL_API_BOOKS\u0026#39;] = \u0026#34;http://microservice_api-books_1:5000/\u0026#34;; 3$_ENV[\u0026#39;URL_API_READERS\u0026#39;] = \u0026#34;http://microservice_api-readers_1:5000/\u0026#34;; 4?\u0026gt;  9 $json = file_get_contents($_ENV[\u0026#39;URL_API_BOOKS\u0026#39;]); 8. Concorr√™ncia \u0026ldquo;Concurrency\u0026rdquo; Aplica√ß√µes web necessitam ser escal√°veis horizontalmente. Logo, elas podem ter 1 ou mais inst√¢ncias de seus microservi√ßos sendo executadas, simultaneamente. Isso aumenta a disponbilidade e concorr√™ncia dos processos.\nComo eu estou trabalhando com o docker-compose, ele, por padr√£o, prepara para um ambiente escal√°vel que pode ser orquestrado no Dokcer Swarm, Kubernetes ou outros. Inclusive, ele sufixa todos os services com numera√ß√µes de 1 a quantidade de r√©plicas criadas:\nName Command State Ports ------------------------------------------------------------------------------------------------ microservice_api-books_1 /usr/src/app/entrypoint.sh Up 0.0.0.0:5000-\u0026gt;5000/tcp microservice_api-readers_1 /usr/src/app/entrypoint.sh Up 0.0.0.0:5001-\u0026gt;5000/tcp microservice_database-books_1 docker-entrypoint.sh postgres Up 5432/tcp microservice_database-readers_1 docker-entrypoint.sh postgres Up 5432/tcp microservice_web_1 docker-php-entrypoint apac ... Up 0.0.0.0:80-\u0026gt;80/tcp 9. Descartabilidade \u0026ldquo;Disposability\u0026rdquo; De acordo com esse fator, todas as inst√¢ncias de microservi√ßos devem ser \u0026ldquo;descartav√©is\u0026rdquo; para iniciar e parar suas execu√ß√µes rapidamente e sem maiores complica√ß√µes, a qualquer tempo. Mais um motivo dos quais eles devem ser stateless (fator 6). Isso facilita o escalonamento r√°pido.\nA pr√≥pria natureza de containers garanti isso!\n10. Dev/prod semelhantes \u0026ldquo;Dev-Prod Parity\u0026rdquo; Manter todas as etapas do desenvolvimento (development, staging,production, etc) mais semalhantes o poss√≠vel √© meta desse fator. Entrega e Desenvolvimento cont√≠nuos (CD) dependem de uma Integra√ß√£o cont√≠nua (CI). Um time de DevOps tende a priorizar por isso.\nMais, uma vez, o uso de containers, por conta de sua padroniza√ß√£o de ambientes em pacotes de imagens, ajuda muito nesse sentido! Viva os containers üòÇ\nQuer aprender a utilizar e administrar containers Docker? Tenho um curso do zero para voc√™! Eu quero o curso agora\n Alternativamente, ferramentas de provisionamento declarativo tais como Chef e Puppet combinado com ambientes virtuais leves como Vagrant tamb√©m permitem desenvolvedores rodar ambientes locais que s√£o bem pr√≥ximos dos ambientes de produ√ß√£o.\n11. Logs Logs fazem parte do pacote do monitoramento, t√£o primordial no universo dos microservi√ßos. Al√©m disso, logs s√£o imprescind√≠veis para debugar e verificar a sa√∫de da aplica√ß√£o. A partir disso, os logs n√£o devem ser armazenados em\narquivo de log de sistema, mas sim tratados como fluxos de eventos cont√≠nuos que devem capturados e armazenados em sistema separado. Por exemplo, a stack ELK ou Graylog.\nNo meu cen√°rio simples tenho clareza e acesso cont√≠nuo aos logs direto da CLI do docker compose. No caso, um recurso nativo do Docker, o \u0026ldquo;docker-compose logs\u0026rdquo;:\nweb_1 | 192.168.160.1 - - [11/Nov/2020:14:13:17 +0000] \u0026#34;GET / HTTP/1.1\u0026#34; 200 401 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\u0026#34; web_1 | 192.168.160.1 - - [11/Nov/2020:14:13:18 +0000] \u0026#34;GET /favicon.ico HTTP/1.1\u0026#34; 404 487 \u0026#34;http://localhost/\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\u0026#34; api_1 | * Serving Flask app \u0026#34;api.py\u0026#34; api_1 | * Environment: production database_1 | 2020-11-11 16:25:37.316 UTC [1] LOG: listening on IPv4 address \u0026#34;0.0.0.0\u0026#34;, port 5432 database_1 | 2020-11-11 16:25:37.316 UTC [1] LOG: listening on IPv6 address \u0026#34;::\u0026#34;, port 5432 12. Processos de Admin \u0026ldquo;Admin Processes\u0026rdquo; Execute tarefas de administra√ß√£o/gerenciamento como processos √∫nicos - tarefas como migra√ß√£o de banco de dados ou execu√ß√£o de scripts √∫nicos no ambiente. O objetivo √© separar da execu√ß√£o do processo do microservi√ßo de um processo de administra√ß√£o como uma consulta ou update de banco, por exemplo.\nNo meu caso, eu uso a pr√≥pria CLI do docker-compose que garante uma execu√ß√£o multiplexada do processo vigente. Isso √© a natureza dos containers Docker:\ndocker-compose exec database-books psql -U test -p 5432 -d books Refer√™ncias  Curso Docker do Zero - Introdu√ß√£o a administra√ß√£o de containers GitHub desse projeto The Twelve-Factor App (pt_BR) The Twelve-Factor App‚Ää‚Äî‚ÄäA Successful Microservices Guideline Book \u0026ldquo;Building Microservices\u0026rdquo; Microservice Architecture The Twelve-Factor App‚Ää‚Äî‚ÄäA Successful Microservices Guideline Simple App with Flask, SQLAlchemy and Docker An example of a RESTful API Deployed on a Docker Container DOCKER COMPOSE WITH TWO CONTAINERS - FLASK REST API SERVICE CONTAINER AND AN APACHE SERVER CONTAINER Python REST APIs With Flask, Connexion, and SQLAlchemy ‚Äì Part 2  ","date":"10 Nov, 2020","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/2020_11_microservico_hue083b78f431fc816fe51537f356dac65_213956_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/2020_11_microservico_hue083b78f431fc816fe51537f356dac65_213956_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/2020_11_microservico_hue083b78f431fc816fe51537f356dac65_213956_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/2020_11_microservico_hue083b78f431fc816fe51537f356dac65_213956_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/2020_11_microservico_hue083b78f431fc816fe51537f356dac65_213956_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1471\" height=\"981\"\u003e\n\u003c/picture\u003e\n \n \n \n\n\n","permalink":"https://ricardoferreira.site/blog/aplicacao-web-microservico-docker-python-php/","tags":["docker","api"],"title":"Aplica√ß√£o web em arquitetura de microservi√ßo utilizando Docker üê≥"},{"categories":["Docker"],"contents":"Depois do an√∫ncio do Windows Subystem for Linux (WSL) em 2016, a Microsoft divulga, em 2019, nova vers√£o do subsistema que permite rodar um Kernel Linux direto no Windows, sem recursos de virtualiza√ß√£o. E isso impacta direto como containers Docker rodar√£o no Windows 10.\nContextualizando Primeiro suporte ao Docker no Windows se deu pelo Docker Toolbox, obsoleto e substitu√≠do pelo Docker for Windows. Ambos, rodando em m√°quina virtual (VM) com suporte via VirtualBox e Hyper-V, respectivamente.\nEm 2016, surgiu o WSL oferecendo uma camada de compatibilidade para gerar bin√°rios execut√°veis do Linux ‚Äúnativamente‚Äù no Windows 10. Fornecendo uma interface de n√∫cleo compat√≠vel com o kernel Linux,¬†ela usava bibliotecas do Kernel Windows (ou seja, sem nenhum c√≥digo Linux).\nMesmo assim, era imposs√≠vel para executar a Docker Engine e o Kubernetes, por exemplo, diretamente dentro do WSL. Em vez disso, a Docker desenvolveu uma solu√ß√£o alternativa usando as VMs do Hyper-V e o LinuxKit para obter a perfeita integra√ß√£o consolidada atualmente ‚Äì o Docker for Windows.\nEnt√£o, chegamos ao WSL 2, lan√ßado em junho de 2019 na vers√£o Preview Build 18917 (20H1) do programa Windows Insider, que permite aos usu√°rios se inscreverem para contribuir pelo desenvolvimento do Windows 10. Em resumo, ao inv√©s de usar a emula√ß√£o, o WSL 2 usa realmente um kernel Linux rodando dentro de uma VM leve. Embora o WSL 2 use tecnologia de virtualiza√ß√£o, ele n√£o √© uma Virtual Machine. Mas, ser√° gerenciado e executado, como tal, ‚Äúpor baixo do cap√¥‚Äù, sem interven√ß√£o direta do usu√°rio.\nRecomendo que leia:\nWSL 2 ‚Äì entenda a nova vers√£o do subsistema que permite rodar um Kernel Linux no Windows 10\nDocker¬†no Windows Para a Docker, conforme publica√ß√£o oficial, essa abordagem √© arquitetonicamente muito pr√≥xima do que √© feito com o LinuxKit e o Hyper-V hoje, com o benef√≠cio adicional de ser mais leve e mais integrado ao Windows do que o Docker pode fornecer sozinho.\n\nPara eles, o WSL 2 veio facilitar a intraoperabilidade do Docker com o Windows, deixar o desenvolvimento e a execu√ß√£o de containers Docker mais r√°pidos.\n The Docker daemon runs well on it with great performance, and the time it takes from a cold boot to have dockerd running in WSL 2 is around 2 seconds on our developer machines. We are very excited about this technology, and we are happy to announce that we are working on a new version of Docker Desktop leveraging WSL 2, with a public preview in July. It will make the Docker experience for developing with containers even greater, unlock new capabilities, and because WSL 2 works on Windows 10 Home edition, so will Docker Desktop.\nVia Docker hearts WSL 2\n O Futuro Como o WSL 2 ainda est√° em preview, a Docker j√° planeja substituir a VM do Hyper-V, suportado no Docker for Windows, por um pacote de integra√ß√£o que fornecer√° os recursos j√° existentes, contudo com suporte nativo ao WSL 2. Este pacote de integra√ß√£o conter√° os componentes necess√°rios para executar o Docker e o Kubernetes, bem como as ferramentas CLI usadas para interagir com esses componentes no WSL 2. Em seguida, poderemos introduzir um novo recurso com os espa√ßos de trabalho do Docker Desktop: Linux.\nAl√©m disso, com a integra√ß√£o do WSL 2, voc√™ ainda ter√° intera√ß√£o maior com programas Linux em execu√ß√£o no WSL. Isso tem um grande impacto para os desenvolvedores que trabalham em projetos voltados para um ambiente Linux.\nPor fim, usu√°rios do Windows poder√£o colocar seus arquivos de aplica√ß√µes diretamente no sistema de arquivos Linux para aproveitar os benef√≠cios de desempenho de arquivos. Isso muda completamente a maneira como era feito antes; j√° que eles deviam ser salvos em sua unidade C ao usar o WSL.\nPara ler mais sobre as principais mudan√ßas, consulte a documenta√ß√£o oficial aqui e nota oficial da Docker sobre o assunto aqui.\n","date":"05 Nov, 2019","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cpicture\u003e\n  \u003csource srcset=\"/images/post/2019_05_windows-10-docker_hu3d03a01dcc18bc5be0e67db3d8d209a6_393706_545x0_resize_q95_h2_box.webp\" media=\"(max-width: 575px)\"\u003e\n  \u003csource srcset=\"/images/post/2019_05_windows-10-docker_hu3d03a01dcc18bc5be0e67db3d8d209a6_393706_600x0_resize_q95_h2_box.webp\" media=\"(max-width: 767px)\"\u003e\n  \u003csource srcset=\"/images/post/2019_05_windows-10-docker_hu3d03a01dcc18bc5be0e67db3d8d209a6_393706_700x0_resize_q95_h2_box.webp\" media=\"(max-width: 991px)\"\u003e\n  \u003csource srcset=\"/images/post/2019_05_windows-10-docker_hu3d03a01dcc18bc5be0e67db3d8d209a6_393706_1110x0_resize_q95_h2_box.webp\"\u003e\n  \u003cimg loading=\"lazy\" decoding=\"async\" class=\"w-100 img-fluid rounded\" src=\"/images/post/2019_05_windows-10-docker_hu3d03a01dcc18bc5be0e67db3d8d209a6_393706_1110x0_resize_q95_box.jpg\" alt=\"\" width=\"1501\" height=\"967\"\u003e\n\u003c/picture\u003e\n \n \n \n\n\n","permalink":"https://ricardoferreira.site/blog/do-docker-toolbox-ao-wsl-2-a-evolucao-do-docker-no-windows/","tags":["docker"],"title":"Do Docker Toolbox ao WSL 2 - a Evolu√ß√£o do Docker no Windows"}]